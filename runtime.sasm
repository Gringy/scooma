/ runtime for scooma version 0.0.4
/ created 23.05.2019
/ Gringy egor@kanev.xyz

/ header structure:
/ 00 link to previous header or 0x00 if last
/ 01 immediate flag
/ 02 link for jump
/ 03 and next - name as null-terminated string 

/ call entry point
i lit jump
r start

/ ===============================
/ === variables and constants ===
/ ===============================
C BUFF_START 4096

/ vars
: Heap
r image_end
: Dict
r word_last
: Buff
r BUFF_START

/ ===================
/ === entry point ===
/ ===================
: start

i bye

/ ====================
/ === common words ===
/ ====================

/ s:get
/ -- <link to line>
: s:get
/ at first drop the buffer
i lit call
r buff:drop
/ then read head spaces and drop it
: s:get--drop-spaces
i get dup lit call
r space?
i not lit cjump
r s:get--start-reading
i drop lit jump
r s:get--drop-spaces
: s:get--start-reading
/ then read word chars to buffer
i lit call
r buff:add
i get dup lit call
r space?
i not lit cjump
r s:get--start-reading
/ then add link to buffer
i drop lit call
r buff:get
i ret

/ space?
/ c -- f
/ 32 - space, 9 - \t, 10 - \n, 13 - \r
: space?
i dup lit eq swap
n 32
i dup lit eq swap
n 9
i dup lit eq swap
n 10
i lit eq
n 13
i or or or ret

/ nl
: nl
i lit emit ret
n 10

/ inc
: inc
i lit add ret
n 1

/ dec
: dec
i lit sub ret
n 1

/ s:put
/ s -- 
/ puts a string to console
: s:put
i dup fetch dup lit
n 0
i eq lit cjump
r s:put:ret
i emit lit add
n 1 
i lit jump
r s:put
: s:put:ret
i drop drop ret

/ buff:add
: buff:add
i lit fetch dup push
r Buff
i store pop lit add
n 1
i dup lit store lit
r Buff
n 0
i swap store ret

/ buff:size
: buff:size
i lit fetch lit
r Buff
r BUFF_START
i sub ret

/ buff:get
: buff:get
i lit ret
r BUFF_START

/ buff:drop
: buff:drop
i lit lit store ret
r BUFF_START
r Buff

/ fetch>
/ <pointer> -- <pointer+1> <cell>
: fetch>
i dup lit add swap
n 1
i fetch ret

/ s:eq?
/ <str2> <str1> -- <eq?>
: s:eq?
i lit call
r fetch>
/ stack here: <str2> <str1+1> <ch1>
i rot lit call
r fetch>
/ stack here: <str1+1> <ch1> <str2+1> <ch2>
i rot
/ stack here: <str1+1> <str2+1> <ch2> <ch1>
i over over eq
/ stack here: <str1+1> <str2+1> <ch2> <ch1> <eq?>
i lit cjump
r s:eq?--char-eq
/ char is not equal: drop all and exit
i drop drop drop drop
i lit ret
n 0
: s:eq?--char-eq
/ stack here: <str1+1> <str2+1> <ch2> <ch1>
i drop lit eq
n 0
/ stack here: <str1+1> <str2+1> <is-zero?>
/ if not end of line - go to start of word
i not lit cjump
r s:eq?
/ else return true
i drop drop lit ret
n -1
i ret

/ dict:next
: dict:next
i fetch ret

/ dict:imm?
: dict:imm?
i lit add fetch ret
n 1

/ dict:xt
: dict:xt
i lit add fetch ret
n 2

/ dict:name
/ <header> -- <name>
: dict:name
i lit add ret
n 3

/ dict:for-each
/ <quote> --
: dict:for-each
i dup push lit fetch
r Dict
: dict:for-each--loop
i dup
i lit eq lit cjump
n 0
r dict:for-each--drop
i dup
i pop dup push call
i fetch lit jump
r dict:for-each--loop
: dict:for-each--drop
i drop drop pop drop
i ret

/ dict:words
/ --
: dict:words
i lit lit call
r dict:words--quote
r dict:for-each
i lit call
r nl
i ret
: dict:words--quote
i lit call
r dict:name
i lit call
r s:put
i lit emit ret
n 32

/ dict:find
/ <name> -- <header address>
: dict:find
i ret

/ s:to-int
/ <string> -- <result-int> <flag-if-done>
: s:to-int
i ret

/ number?
/ <char> -- <flag-if-number>
: number?
i dup lit beq
n 48
i swap lit leq
n 57
i and ret

/ ========================
/ === dict starts here ===
/ ========================
: word0
n 0
n 0
r inc
s inc

: word1
r word0
n 0
r dec
s dec

: word2
r word1
n 0
r s:put
s s:put

: word3
r word2
n 0
r space?
s space?

: word4
r word3
n 0
r s:get
s s:get

: word5
r word4
n 0
r dict:imm?
s dict:imm?

: word6
r word5
n 0
r dict:xt
s dict:xt

: word7
r word6
n 0
r dict:name
s dict:name

: word8
r word7
n 0
r nl
s nl

: word9
r word8
n 0
r s:eq?
s s:eq?

: word10
r word9
n 0
r dict:for-each
s dict:for-each

: word11
r word10
n 0
r dict:words
s dict:words

: word12
r word11
n 0
r fetch>
s fetch>

: word13
r word12
n 0
r s:to-int
s s:to-int

: word14
r word13
n 0
r dict:find
s dict:find

: word_last
: word15
r word14
n 0
r number?
s number?

: image_end
