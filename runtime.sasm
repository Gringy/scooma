/ runtime for scooma version 0.0.6
/ created 23.05.2019
/ Gringy egor@kanev.xyz

/ header structure:
/ 00 link to previous header or 0x00 if last
/ 01 immediate flag
/ 02 link for jump
/ 03 and next - name as null-terminated string 

/ call entry point
i lit jump
r start

/ ===============================
/ === variables and constants ===
/ ===============================
C BUFF_START 4096

/ vars
: Heap
r image_end
: Dict
r word_last
: Buff
r BUFF_START

/ ===================
/ === entry point ===
/ ===================
: start
i lit call
r interpret
i lit jump
r start
i bye

/ ====================
/ === common words ===
/ ====================

/ s:get
/ -- <link to line>
: s:get
/ at first drop the buffer
i lit call
r buff:drop
/ then read head spaces and drop it
: s:get--drop-spaces
i get dup lit call
r space?
i not lit cjump
r s:get--start-reading
i drop lit jump
r s:get--drop-spaces
: s:get--start-reading
/ then read word chars to buffer
i lit call
r buff:add
i get dup lit call
r space?
i not lit cjump
r s:get--start-reading
/ then add link to buffer
i drop lit call
r buff:get
i ret

/ space?
/ c -- f
/ 32 - space, 9 - \t, 10 - \n, 13 - \r
: space?
i dup lit eq swap
n 32
i dup lit eq swap
n 9
i dup lit eq swap
n 10
i lit eq
n 13
i or or or ret

/ nl
: nl
i lit emit ret
n 10

/ inc
: inc
i lit add ret
n 1

/ dec
: dec
i lit sub ret
n 1

/ s:put
/ s -- 
/ puts a string to console
: s:put
i dup fetch dup lit
n 0
i eq lit cjump
r s:put:ret
i emit lit add
n 1 
i lit jump
r s:put
: s:put:ret
i drop drop ret

/ buff:add
: buff:add
i lit fetch dup push
r Buff
i store pop lit add
n 1
i dup lit store lit
r Buff
n 0
i swap store ret

/ buff:size
: buff:size
i lit fetch lit
r Buff
r BUFF_START
i sub ret

/ buff:get
: buff:get
i lit ret
r BUFF_START

/ buff:drop
: buff:drop
i lit lit store ret
r BUFF_START
r Buff

/ fetch>
/ <pointer> -- <pointer+1> <cell>
: fetch>
i dup lit add swap
n 1
i fetch ret

/ s:eq?
/ <str2> <str1> -- <eq?>
: s:eq?
i lit call
r fetch>
/ stack here: <str2> <str1+1> <ch1>
i rot lit call
r fetch>
/ stack here: <str1+1> <ch1> <str2+1> <ch2>
i rot
/ stack here: <str1+1> <str2+1> <ch2> <ch1>
i over over eq
/ stack here: <str1+1> <str2+1> <ch2> <ch1> <eq?>
i lit cjump
r s:eq?--char-eq
/ char is not equal: drop all and exit
i drop drop drop drop
i lit ret
n 0
: s:eq?--char-eq
/ stack here: <str1+1> <str2+1> <ch2> <ch1>
i drop lit eq
n 0
/ stack here: <str1+1> <str2+1> <is-zero?>
/ if not end of line - go to start of word
i not lit cjump
r s:eq?
/ else return true
i drop drop lit ret
n -1
i ret

/ dict:next
: dict:next
i fetch ret

/ dict:class
: dict:class
i lit add fetch ret
n 1

/ dict:xt
: dict:xt
i lit add fetch ret
n 2

/ dict:name
/ <header> -- <name>
: dict:name
i lit add ret
n 3

/ dict:for-each
/ <quote> --
: dict:for-each
i dup push lit fetch
r Dict
: dict:for-each--loop
i dup
i lit eq lit cjump
n 0
r dict:for-each--drop
i dup
i pop dup push call
i fetch lit jump
r dict:for-each--loop
: dict:for-each--drop
i drop drop pop drop
i ret

/ dict:words
/ --
: dict:words
i lit lit call
r dict:words--quote
r dict:for-each
i lit call
r nl
i ret
: dict:words--quote
i lit call
r dict:name
i lit call
r s:put
i lit emit ret
n 32

/ dict:find
/ <name> -- <header address>
: dict:find
i push lit fetch
r Dict
: dict:find--loop
/ header
i dup lit eq
n 0
/ header <is-last-word?>
i lit cjump
r dict:find--success
i dup lit call
r dict:name
/ header header-name
i pop dup push
/ header header-name <name>
i lit call
r s:eq?
/ header <eq?>
i lit cjump
r dict:find--success
/ not equal, go to next header
i fetch lit jump
r dict:find--loop
: dict:find--success
i pop drop ret

/ s:to-int
/ <string> -- <result-int> <flag-if-done>
: s:to-int
i dup fetch lit eq
/ 45 is '-'
n 45
i not lit cjump
r s:to-int--positive
/ negative
i lit push
n -1
/ skip dash in the start of string
i lit add
n 1
i lit jump
r s:to-int--start-loop
: s:to-int--positive
i lit push
n 1
: s:to-int--start-loop
i lit swap
n 0
/ <number> <str>
: s:to-int--loop
i lit call
r fetch>
/ <number> <str+1> <char>
i dup lit eq
n 0
i lit cjump
r s:to-int--success
i dup lit call
r number?
/ <number> <str+1> <char> <is-valid?> 
i not lit cjump
r s:to-int--invalid
i lit sub
/ 48 is '0'
n 48
i rot lit mul add
n 10
/ <str+1> <number*10+char>
i swap lit jump
r s:to-int--loop
: s:to-int--success
i drop drop
i pop mul lit ret
n -1
: s:to-int--invalid
i pop drop
i drop drop lit ret
n 0

/ number?
/ <char> -- <flag-if-number>
: number?
i dup lit beq
/ 48 is '0'
n 48
i swap lit leq
/ 57 is '9'
n 57
i and ret

/ class:word
/ <xt> --
: class:word
i call
i ret

/ class:low
/ <xt> --
: class:low
i ret

/ interpret
/ --
: interpret
i lit call
r s:get
i dup lit call
r dict:find
/ <str> <header>
i dup lit eq
n 0
i lit cjump
r interpret--number
i swap drop
/ <header>
i dup lit call
r dict:xt
i swap lit call
r dict:class
i call
i ret

: interpret--number
i drop lit call
r s:to-int
i not cjump
r interpret--not-found
i ret

: interpret--not-found
i lit lit call
r str-not-found
r s:put
i ret

: str-not-found
s word not found\n

/ ====================
/ === native words ===
/ ====================

: n:put
i dot ret

: debug
i debug ret

: bye
i bye

/ ========================
/ === dict starts here ===
/ ========================
: word0
n 0
r class:word
r inc
s inc

: word1
r word0
r class:word
r dec
s dec

: word2
r word1
r class:word
r s:put
s s:put

: word3
r word2
r class:word
r space?
s space?

: word4
r word3
r class:word
r s:get
s s:get

: word5
r word4
r class:word
r dict:class
s dict:class

: word6
r word5
r class:word
r dict:xt
s dict:xt

: word7
r word6
r class:word
r dict:name
s dict:name

: word8
r word7
r class:word
r nl
s nl

: word9
r word8
r class:word
r s:eq?
s s:eq?

: word10
r word9
r class:word
r dict:for-each
s dict:for-each

: word11
r word10
r class:word
r dict:words
s dict:words

: word12
r word11
r class:word
r fetch>
s fetch>

: word13
r word12
r class:word
r s:to-int
s s:to-int

: word14
r word13
r class:word
r dict:find
s dict:find

: word15
r word14
r class:word
r number?
s number?

: word16
r word15
r class:word
r n:put
s n:put

: word_last
: word17
r word16
r class:word
r debug
s debug

: word_last
: word18
r word17
r class:word
r bye
s bye

: image_end
